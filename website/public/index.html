<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Example of Sampling Profiler in JavaScript"
    />
    <title>RUM Sampling Profiler in JavaScript</title>
    <script>
      (async () => {
        let t = 1,
          n = [];
        const e = new PerformanceObserver(e => {
          const s = e.getEntries();
          for (const e of s)
            n.push({
              id: `${t}`,
              name: e.name,
              start: Math.round(e.startTime),
              end: Math.round(e.startTime + e.duration),
              duration: Math.round(e.duration)
            }),
              t++;
        });
        e.observe({ type: "longtask" });
        const s = await performance.profile({
          categories: ["js"],
          sampleInterval: 0.1,
          sampleBufferSize: Number.MAX_SAFE_INTEGER
        });
        function r(t, n) {
          return (function(t, n) {
            let { name: e, line: s, column: r, resourceId: o } = n;
            if (!e && !s && !r) return "unknown";
            e || (e = "anonymous");
            if (!s || !r) return `${e} (native code)`;
            const c = (function(t, n) {
              return t.resources[n];
            })(t, o);
            return `${e} (${c}:${s}:${r})`;
          })(
            t,
            (function(t, n) {
              return t.frames[n];
            })(t, n.frameId)
          );
        }
        function o(t, n) {
          return t.stacks[n];
        }
        function c(t, n, e = []) {
          if (!n) return e;
          const { parentId: s } = n;
          if (null != s) {
            return e.unshift(r(t, n)), c(t, o(t, s), e);
          }
          return e.unshift(r(t, n)), e;
        }
        function i(t, n) {
          return { name: t.split("$#")[0], value: n, children: [] };
        }
        setTimeout(async function() {
          e.disconnect();
          const t = (function(t) {
              const e = {};
              for (const s of t.samples) {
                const r = Math.round(s.timestamp);
                for (const c of n) {
                  const { start: n, name: i, id: a, end: u, duration: f } = c;
                  if (
                    (e[a] ||
                      (e[a] = {
                        name: i,
                        start: n,
                        end: u,
                        duration: f,
                        culprits: []
                      }),
                    r >= n && r <= u)
                  ) {
                    const n = o(t, s.stackId);
                    e[a].culprits.push({
                      time: r,
                      stackId: s.stackId,
                      stack: n
                    });
                  }
                }
              }
              return (
                (function(t, n) {
                  Object.keys(t).forEach(e => {
                    const { culprits: s, start: r, end: o } = t[e],
                      i = [];
                    let a = r;
                    for (let t = 0, e = 1; e < s.length + 1; t++, e++) {
                      let r = s[t],
                        u = s[e];
                      for (; u && u.stackId === r.stackId; )
                        e++, (r = s[++t]), (u = s[e]);
                      const f = e === s.length,
                        l = f ? r.time - a + (o - r.time) : r.time - a;
                      i.push({ selfTime: l, frames: c(n, r.stack) }),
                        (a = r.time);
                    }
                    t[e].culprits = i;
                  });
                })(e, t),
                e
              );
            })(await s.stop()),
            r = [];
          Object.keys(t).forEach(n => {
            const e = t[n],
              s = (function(t) {
                const n = new Map(),
                  { culprits: e, name: s, duration: r } = t,
                  o = i(`Longtask (${s})`, r);
                let c = null;
                for (const t of e) {
                  const { selfTime: e, frames: s } = t;
                  if (0 !== s.length) {
                    for (let t = 0; t < s.length; t++) {
                      const r = s[t],
                        o = `${r}$#${t}`;
                      n.has(o) ||
                        n.set(o, { children: [], selfTime: 0, seen: !1 });
                      const i = n.get(o);
                      c
                        ? (i.selfTime + e <= c.selfTime && (i.selfTime += e),
                          -1 === c.children.indexOf(o) && c.children.push(o))
                        : (i.selfTime += e),
                        (c = i);
                    }
                    c = null;
                  }
                }
                const a = (t, e, s) => {
                  const r = i(t, e.selfTime);
                  s.children.push(r);
                  for (const t of e.children) {
                    const e = n.get(t);
                    a(t, e, r);
                  }
                  e.seen = !0;
                };
                for (const [t, e] of n.entries()) e.seen || a(t, e, o);
                return o;
              })(e);
            r.push({ data: s, start: e.start, end: e.end });
          }),
            (window.PROFILED_DATA = r);
        }, 3e3);
      })();
    </script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
